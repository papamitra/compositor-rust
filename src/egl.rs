use xcb;
use libloading::Library;
use nix::libc::{c_void};
use std::ffi::{CString};
use std::ptr;
use std::mem::transmute;

use wayland_server::sys::*;

error_chain!{}

// for bindings.rs (generated by gl-generator)

#[allow(non_camel_case_types, dead_code)]
mod ffi {
    use nix::libc::{c_long, c_void, int32_t, uint64_t};

    pub type khronos_utime_nanoseconds_t = khronos_uint64_t;
    pub type khronos_uint64_t = uint64_t;
    pub type khronos_ssize_t = c_long;
    pub type EGLint = int32_t;
    pub type EGLNativeDisplayType = NativeDisplayType;
    pub type EGLNativePixmapType = NativePixmapType;
    pub type EGLNativeWindowType = NativeWindowType;
    pub type NativeDisplayType = *const c_void;
    pub type NativePixmapType = *const c_void;
    pub type NativeWindowType = *const c_void;

    pub mod egl {
        use super::*;
        include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
    }
}

use self::ffi::*;

lazy_static! {
    static ref LIBEGL: Library = Library::new("libEGL.so.1").unwrap();
}

fn load_egl(lib: &Library) -> egl::Egl {
    egl::Egl::load_with(|sym| {
        let name = CString::new(sym).unwrap();
        unsafe {
            let symbol = lib.get::<*mut c_void>(name.as_bytes());
            match symbol {
                Ok(x) => {
                    *x as *const _
                },
                Err(_) => ptr::null(),
            }
        }
    })
}

pub fn egl_init(raw_display: *mut wl_display) -> Result<xcb::Connection> {
    let (conn, screen_num) = xcb::Connection::connect_with_xlib_display().unwrap();

    {
        let setup = conn.get_setup();

        let screen = setup.roots().nth(0 as usize).unwrap();
        // let foreground = conn.generate_id();
        // xcb::create_gc(
        //     &conn,
        //     foreground,
        //     screen.root(),
        //     &[
        //         (xcb::GC_FOREGROUND, screen.black_pixel()),
        //         (xcb::GC_GRAPHICS_EXPOSURES, 0),
        //     ],
        // );

        let win = conn.generate_id();
        xcb::create_window(
            &conn,
            xcb::COPY_FROM_PARENT as u8,
            win,
            screen.root(),
            0,
            0,
            1024,
            768,
            10,
            xcb::WINDOW_CLASS_INPUT_OUTPUT as u16,
            screen.root_visual(),
            &[]
        );

        xcb::map_window(&conn, win);
        conn.flush();
    }

    let p = load_egl(&LIBEGL);
    unsafe {
        let egl_display = {

            let get_display_loader = p.GetProcAddress(CString::new("eglGetPlatformDisplayEXT").unwrap().as_ptr());
            let get_display : fn(egl::types::EGLenum,
                                  *mut _, *const egl::types::EGLint) -> egl::types::EGLDisplay = transmute(get_display_loader);
            get_display(
                egl::PLATFORM_X11_KHR,
                conn.get_raw_dpy() as *mut _,
                ptr::null())
        };

        {
            let mut major : EGLint = 0;
            let mut minor : EGLint = 0;

            let ret = p.Initialize(egl_display, &mut major, &mut minor);
            assert!(ret == true as u32);
            println!("EGL version: {}.{}", major, minor);
        }

        {
            let bind_display_loader = p.GetProcAddress(CString::new("eglBindWaylandDisplayWL").unwrap().as_ptr());
            let bind_display : fn(egl::types::EGLDisplay,
                                  *mut wl_display) -> egl::types::EGLBoolean = transmute(bind_display_loader);
            let ret = bind_display(egl_display, raw_display);

            println!("bind_display ret: {:?}", ret);
        }
    }

    Ok(conn)
}
