
use xcb;
use libloading::Library;
use nix::libc::c_void;
use std::ffi::CString;
use std::ptr;
use std::mem::transmute;
use std::os;
use std::mem;

use glium;

use wayland_server::sys::*;

error_chain! {
    errors {
        ConfigError {
            description("ConfigError")
        }

        CreateSurfaceError {
        }

        CreateContextError {
        }

        MakeCurrentError {
        }

    }
}

// for bindings.rs (generated by gl-generator)

#[allow(non_camel_case_types, dead_code)]
mod ffi {
    use nix::libc::{c_long, c_void, int32_t, uint64_t};

    pub type khronos_utime_nanoseconds_t = khronos_uint64_t;
    pub type khronos_uint64_t = uint64_t;
    pub type khronos_ssize_t = c_long;
    pub type EGLint = int32_t;
    pub type EGLNativeDisplayType = NativeDisplayType;
    pub type EGLNativePixmapType = NativePixmapType;
    pub type EGLNativeWindowType = NativeWindowType;
    pub type NativeDisplayType = *const c_void;
    pub type NativePixmapType = *const c_void;
    pub type NativeWindowType = *const c_void;

    pub mod egl {
        use super::*;
        include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
    }
}

use self::ffi::*;

lazy_static! {
    static ref LIBEGL: Library = Library::new("libEGL.so.1").unwrap();
}

fn load_egl(lib: &Library) -> egl::Egl {
    egl::Egl::load_with(|sym| {
        let name = CString::new(sym).unwrap();
        unsafe {
            let symbol = lib.get::<*mut c_void>(name.as_bytes());
            match symbol {
                Ok(x) => *x as *const _,
                Err(_) => ptr::null(),
            }
        }
    })
}

pub struct Backend {
    conn: xcb::Connection,
    egl_display: egl::types::EGLDisplay,
    egl_context: egl::types::EGLContext,
    egl_surface: egl::types::EGLSurface,
}

impl Backend {
    pub fn new(wl_display: *mut wl_display) -> Result<Self> {

        let (conn, screen_num) = xcb::Connection::connect_with_xlib_display().unwrap();

        let native_window = {
            let setup = conn.get_setup();

            let screen = setup.roots().nth(0 as usize).unwrap();
            // let foreground = conn.generate_id();
            // xcb::create_gc(
            //     &conn,
            //     foreground,
            //     screen.root(),
            //     &[
            //         (xcb::GC_FOREGROUND, screen.black_pixel()),
            //         (xcb::GC_GRAPHICS_EXPOSURES, 0),
            //     ],
            // );

            let win = conn.generate_id();
            xcb::create_window(
                &conn,
                xcb::COPY_FROM_PARENT as u8,
                win,
                screen.root(),
                0,
                0,
                1024,
                768,
                10,
                xcb::WINDOW_CLASS_INPUT_OUTPUT as u16,
                screen.root_visual(),
                &[],
            );

            xcb::map_window(&conn, win);
            conn.flush();
            win
        };

        let p = load_egl(&LIBEGL);
        unsafe {
            let egl_display = {

                let get_display_loader =
                    p.GetProcAddress(CString::new("eglGetPlatformDisplayEXT").unwrap().as_ptr());
                let get_display: fn(egl::types::EGLenum,
                                    *mut _,
                                    *const egl::types::EGLint)
                                    -> egl::types::EGLDisplay = transmute(get_display_loader);
                get_display(
                    egl::PLATFORM_X11_KHR,
                    conn.get_raw_dpy() as *mut _,
                    ptr::null(),
                )
            };

            {
                let mut major: EGLint = 0;
                let mut minor: EGLint = 0;

                let ret = p.Initialize(egl_display, &mut major, &mut minor);
                assert!(ret == true as u32);
                println!("EGL version: {}.{}", major, minor);
            }

            {
                let bind_display_loader =
                    p.GetProcAddress(CString::new("eglBindWaylandDisplayWL").unwrap().as_ptr());
                let bind_display: fn(egl::types::EGLDisplay, *mut wl_display)
                                     -> egl::types::EGLBoolean = transmute(bind_display_loader);
                let ret = bind_display(egl_display, wl_display);

                println!("bind_display ret: {:?}", ret);
            }

            {
                let attr = vec![
                    egl::BLUE_SIZE,       8,
                    egl::GREEN_SIZE,      8,
                    egl::RED_SIZE,        8,
                    egl::RENDERABLE_TYPE, egl::OPENGL_ES2_BIT,
                    egl::NONE,
                ];
                let mut num_configs = mem::uninitialized();
                let mut config = mem::uninitialized();

                if p.ChooseConfig(
                    egl_display,
                    attr.as_ptr() as *const i32,
                    &mut config,
                    1,
                    &mut num_configs,
                ) == 0
                {
                    bail!(ErrorKind::ConfigError);
                }

                if num_configs != 1 {
                    bail!(ErrorKind::ConfigError);
                }

                let mut format = mem::uninitialized();

                p.GetConfigAttrib(
                    egl_display,
                    config,
                    egl::NATIVE_VISUAL_ID as i32,
                    &mut format,
                );
                let egl_surface = p.CreateWindowSurface(
                    egl_display,
                    config,
                    native_window as *const c_void,
                    ptr::null(),
                );

                if egl_surface == egl::NO_SURFACE {
                    bail!(ErrorKind::CreateSurfaceError);
                }

                let ctx_attr = vec![egl::CONTEXT_CLIENT_VERSION, 2, egl::NONE];
                let egl_context = p.CreateContext(
                    egl_display,
                    config,
                    egl::NO_CONTEXT,
                    ctx_attr.as_ptr() as *const i32,
                );
                if egl_context == egl::NO_CONTEXT {
                    bail!(ErrorKind::CreateContextError);
                }

                if p.MakeCurrent(egl_display, egl_surface, egl_surface, egl_context) == 0 {
                    bail!(ErrorKind::MakeCurrentError);
                }

                Ok(Backend {
                    conn: conn,
                    egl_display: egl_display,
                    egl_context: egl_context,
                    egl_surface: egl_surface,
                })
            }
        }
    }
}

unsafe impl glium::backend::Backend for Backend {
    fn swap_buffers(&self) -> ::std::result::Result<(), glium::SwapBuffersError> {
        let p = load_egl(&LIBEGL);
        unsafe {
            p.SwapBuffers(self.egl_display, self.egl_surface);
            Ok(())
        }
    }

    unsafe fn get_proc_address(&self, symbol: &str) -> *const os::raw::c_void {
        let p = load_egl(&LIBEGL);
        p.GetProcAddress(CString::new(symbol).unwrap().as_ptr()) as *const os::raw::c_void
    }

    fn is_current(&self) -> bool {
        let p = load_egl(&LIBEGL);
        unsafe { p.GetCurrentContext() == self.egl_context as *const _}
    }

    unsafe fn make_current(&self) {
        let p = load_egl(&LIBEGL);
        p.MakeCurrent(
            self.egl_display,
            self.egl_surface,
            self.egl_surface,
            self.egl_context,
        );
    }

    fn get_framebuffer_dimensions(&self) -> (u32, u32) {
        (128, 128)
    }
}
